<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>LRM Adapter Tutorial</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="gram5-developer-lrm-adapter-tutorial">LRM Adapter Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph">
<p>GRAM5 provides a resource-independent abstraction to remote job
management. The resource abstraction contains methods for job submission
and cancelling, and a method for monitoring job state changes. This set
of tutorials describes how to implement and bundle all packages needed
for a complete LRM Adapter interface for GRAM5.</p>
</div>
<div class="paragraph">
<p>For purposes of this tutorial, we will create a fake LRM adapter that
pretends to run jobs, but in fact just keeps track of jobs and expires
them after the job&#8217;s max_wall_time expires. We&#8217;ll call this LRM the
fake LRM adapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parts_of_a_gram5_lrm_adapter">Parts of a GRAM5 LRM Adapter</h3>
<div class="paragraph">
<p>A GRAM5 LRM Adapter consists of a few parts which work together to
provide a full interface between the GRAM5 Job Manager and the Local
Resource Manager. These parts include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>RSL Validation File</strong></dt>
<dd>
<p>An option file which defines any custom RSL attributes which the LRM Adapter implements, or sets any custom defaults for RSL attributes that the LRM processes. Defining new RSL attributes in this file allows the GRAM5 service to detect some sets of RSL errors without invoking the Perl LRM Adapter Module. For this example, the file will be called fake.rvf..</p>
</dd>
<dt class="hdlist1"><strong>Perl LRM Adapter Module</strong></dt>
<dd>
<p>A Perl module which implements the execution interface to the LRM. This module translates the Resource Specification Language description of a job&#8217;s requirements to a concrete way of starting the job on a particular LRM. For this example, this file will be called fake.pm..</p>
</dd>
<dt class="hdlist1"><strong>Configuration File</strong></dt>
<dd>
<p>The GRAM5 service implements a simple configuration file parser which can be used to provide a way to add site customizations to LRM Adapters. These files are usually shared between the Perl LRM Adapter Module and the Scheduler Event Generator Module. For this example, this file will be called fake.conf..</p>
</dd>
<dt class="hdlist1"><strong>Gatekeeper Service File</strong></dt>
<dd>
<p>The Gatekeeper is a privileged service which authenticates and authorizes clients and then starts a Job Manager process on their behalf. The Gatekeeper Service File contains the LRM-specific command-line options to the job manager. For this example, this file will be called jobmanager-fork..</p>
</dd>
<dt class="hdlist1"><strong>Scheduler Event Generator Module</strong></dt>
<dd>
<p>A dynamic object which parses LRM state and generates job state change events in a generic format for GRAM5 to consume. For this example, the SEG module will be called libglobus_seg_fake.so..</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="gram5-lrma-tutorial-rvf">RSL Validation File</h3>
<div class="paragraph">
<p>Each LRM Adapter can have a custom RSL validation file (RVF) which
indicates which RSL attributes are valid for that LRM, what their
default values are, and when they can be used during a job lifecycle.</p>
</div>
<div class="paragraph">
<p>The RVF entries consist of a set of records containing attribute-value
pairs, with a blank line separating records. Each attribute-value pair
is separated by the colon character. The value may be quoted with the
double-quote character, in which case, the value continues until a
second quote character is found; otherwise, the value terminates at end
of line.</p>
</div>
<div class="sect3">
<h4 id="_rvf_attributes">RVF Attributes</h4>
<div class="paragraph">
<p>The attribute names understood by the GRAM5 RVF parser are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Attribute</strong></dt>
<dd>
<p>The name of an RSL attribute.</p>
</dd>
<dt class="hdlist1"><strong>Description</strong></dt>
<dd>
<p>A textual description of the attribute.</p>
</dd>
<dt class="hdlist1"><strong>RequiredWhen</strong></dt>
<dd>
<p>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</a> describing when this RSL attribute must be present.</p>
</dd>
<dt class="hdlist1"><strong>DefaultWhen</strong></dt>
<dd>
<p>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</a> describing when the default RSL value will be applied if it&#8217;s not present in the RSL.</p>
</dd>
<dt class="hdlist1"><strong>ValidWhen</strong></dt>
<dd>
<p>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</a> describing when the RSL attribute may be present.</p>
</dd>
<dt class="hdlist1"><strong>Default</strong></dt>
<dd>
<p>A literal RSL value sequence containing the default value of the attribute, applied to the RSL when the attribute is not present, but the RSL use matches the DefaultWhen value.</p>
</dd>
<dt class="hdlist1"><strong>Values</strong></dt>
<dd>
<p>A sequence of strings enumerating the legal values for the RSL attribute.</p>
</dd>
<dt class="hdlist1"><strong>Publish</strong></dt>
<dd>
<p>When set to true, the RSL attribute will be added to the documentation for the LRM Adapter if the RVF is processed by the <strong>create_rsl_documentation.pl</strong> script. Otherwise, it will not be mentioned.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="gram5-lrma-tutorial-rvf-when-values">RVF When Values</h5>
<div class="paragraph">
<p>The 'WHEN-VALUES' used by the RVF parser are described in this list:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>GLOBUS_GRAM_JOB_SUBMIT</strong></dt>
<dd>
<p>RSL Attribute used in a GRAM5 job request to submit a job to an LRM Adapter.</p>
</dd>
<dt class="hdlist1"><strong>GLOBUS_GRAM_JOB_RESTART</strong></dt>
<dd>
<p>RSL Attribute used in a GRAM5 job request to restart a job which was stopped due to a two-phase commit timeout.</p>
</dd>
<dt class="hdlist1"><strong>GLOBUS_GRAM_JOB_STDIO_UPDATE</strong></dt>
<dd>
<p>RSL Attribute used in a GRAM5 STDIO_UPDATE signal, which may be sent to a job during the two-phase end state.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_common_rsl_attributes">Common RSL Attributes</h5>
<div class="paragraph">
<p>The GRAM5 service by default implements a common set of RSL attributes
for all jobs. Not all of these may be relevant to all LRM types, but are
included in the common set so that the same concept will be processed by
the same attribute for each LRM. LRM Adapters can disable particular RSL
attributes if they want by adding the attribute to their RVF file with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Attribute: AttributeName
ValidWhen: ""</pre>
</div>
</div>
<div class="paragraph">
<p>The common list of attributes is described in
<a href="../../gram5/pi/index.html#gram5-rsl-attribute-summary">RSL Attribute
Summary</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_rsl_validation_file_for_the_fake_lrm">Creating a RSL Validation File for the Fake LRM</h4>
<div class="paragraph">
<p>Normally, the RVF for a new LRM Adapter will add any LRM-specific RSL
attributes and perhaps change the DefaultValue for some. For the
fake LRM, we&#8217;ll be a bit more complicated and disable most of the
GRAM common RSL attributes and reduce things to indicate the queue and
execution time for the fake jobs. The fake.rvf will do the
following:  will do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove executable, arguments, directory, environment, file_clean_up, file_stage_in, file_stage_out, file_stage_in_shared, gass_cache, gram_my_job, host_count, library_path, max_cpu_time, min_memory, project, queue, remote_io_url, scratch_dir, stdin, stdout, and stderr attributes.</p>
</li>
<li>
<p>Add a max_queue_time attribute, which will be the maximum time a particular fake job will be in the PENDING state. This will have a default of 20 minutes.</p>
</li>
<li>
<p>Add a default value to the max_wall_time attribute of 5 minutes.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 1. fake.rvf</div>
<div class="content">
<div class="paragraph">
<p>Here is the <a href="fake.rvf">complete RVF</a> for the fake LRM Adapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Disable a large number of RSL attributes
Attribute: executable
ValidWhen: ""
RequiredWhen: ""

Attribute: directory
ValidWhen: ""
RequiredWhen: ""

Attribute: environment
ValidWhen: ""
RequiredWhen: ""

Attribute: file_clean_up
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_out
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in_shared
ValidWhen: ""
RequiredWhen: ""

Attribute: gass_cache
ValidWhen: ""
RequiredWhen: ""

Attribute: gram_my_job
ValidWhen: ""
RequiredWhen: ""

Attribute: host_count
ValidWhen: ""
RequiredWhen: ""

Attribute: library_path
ValidWhen: ""
RequiredWhen: ""

Attribute: max_cpu_time
ValidWhen: ""
RequiredWhen: ""

Attribute: min_memory
ValidWhen: ""
RequiredWhen: ""

Attribute: project
ValidWhen: ""
RequiredWhen: ""

Attribute: queue
ValidWhen: ""
RequiredWhen: ""

Attribute: remote_io_url
ValidWhen: ""
RequiredWhen: ""

Attribute: scratch_dir
ValidWhen: ""
RequiredWhen: ""

Attribute: stdin
ValidWhen: ""
RequiredWhen: ""

Attribute: stdout
ValidWhen: ""
RequiredWhen: ""

Attribute: stderr
ValidWhen: ""
RequiredWhen: ""

# Add a new attribute max_queue_time
Attribute: max_queue_time
ValidWhen: GLOBUS_GRAM_JOB_SUBMIT
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT
Description: "Maximum time a fake job will be in pending, in seconds. The
              default value is 1200 seconds (20 minutes)"
Default: 1200

# Add a default value and requirement for max_wall_time
Attribute: max_wall_time
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT
Default: 300
Description: "Maximum time a fake job will be in the ACTIVE state"</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_file">Configuration File</h3>
<div class="paragraph">
<p>For the fake LRM, there&#8217;s not much to configure: a path to a file where
the LRM should write its job files. For real LRMs, there are other
things which might belong there: paths to LRM-specific executables such
as <strong>qsub</strong>, tuning parameters fo the LRM adapter script such as the
number of available cores per execution node, or the host to contact
when using a remote submit protocol between GRAM the the LRM. The
configuation parameters used by the LRM adapters included in GRAM5 are
described in <a href="../../gram5/admin/index.html#gram5-configuring-lrm">LRM
Adapter Configuration</a>.</p>
</div>
<div class="paragraph">
<p>The LRM adapter configuration files consist of attribute="value" pairs,
which comment lines beginning with the # character. For the example
fake LRM, the configuration file looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># log_path is the path to log file that the  fake LRM generates. This file is
# updated each time a job is submitted or cancelled. The default if it is not
# present is ${localstatedir}/fake, which is typically /var/fake
log_path="/tmp"</pre>
</div>
</div>
<div class="sect3">
<h4 id="_parsing_the_configuration_file">Parsing the Configuration File</h4>
<div class="paragraph">
<p>The Globus Toolkit contains API functions for parsing files in the
format used by the LRM configuration files. In Perl, use the
Globus::Core::Config class. In C, use the
<strong>globus_common_get_attribute_from_config_file()</strong> function.</p>
</div>
<div class="sect4">
<h5 id="_perl_api">Perl API</h5>
<div class="paragraph">
<p>The Globus::Core::Config API is quite simple. The <strong>new()</strong>
constructor parses the configuration file and returns an object
containing the attribute=value pairs. The <strong>get_attribute()</strong> method
returns the value of the named attribute. These functions are used in
<a href="#gram5-LRM-Adapter-Perl-Config">the fake LRM Perl Module</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_c_api">C API</h5>
<div class="paragraph">
<p>The <strong>globus_common_get_attribute_from_config_file()</strong> function will
load the configuration file and return the value of the attribute passed
to it. This function is ued in the SEG module below. Note that this
function returns a pointer to a copy of the string value in the location
pointed to by the 'value' parameter. The caller must free this value.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gram5-lrma-tutorial-perl">LRM Adapter Perl Module</h3>
<div class="paragraph">
<p>The Perl-language LRM module provides the job submission and cancelling
interface between GRAM5 and the underlying scheduler. Very little has
been added to this part of the scheduler interface since Globus Toolkit
2---if you have a version for an older Globus Toolkit release, you can
ignore most of this tutorial and jump to the
<a href="#gram5-lrma-tutorial-perl-changes">Changes from Previous Versions</a> section
of this tutorial. The
module annotated below is available from link:fake.pm.</p>
</div>
<div class="sect3">
<h4 id="_perl_lrm_adapter_module">Perl LRM Adapter Module</h4>
<div class="paragraph">
<p>The LRM Adapter interface is implemented as a Perl module which is a
subclass of the Globus::GRAM::JobManager module. Its name must match
the type string used when the job manager is started, but in all lower
case: for the fake LRM, the module name is
Globus::GRAM::JobManager::fake and it is stored in the file
fake.pm. Though there are several methods in the . Though there are
several methods in the
<a href="#Globus::GRAM::JobManager">Globus::GRAM::JobManager interface</a>,
the only ones which absolutely need to be implemented in a scheduler
module are <strong>submit</strong> and <strong>cancel</strong>. The <strong>poll</strong> can be
used if there is no SEG module for your LRM Adapter, but using polling
can be resource intensive and slow. We&#8217;ll present the methods in the
module one by one, but the entire module can be downloaded from here:
<a href="fake.pm">fake.pm</a>.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll begin by looking at the start of the fake.pm source module To
begin the script, we import the GRAM support modules into the LRM
adapter module&#8217;s namespace, declare the module&#8217;s package, and declare
this module as a subclass of the  source module To begin the script, we
import the GRAM support modules into the LRM adapter module&#8217;s namespace,
declare the module&#8217;s package, and declare this module as a subclass of
the Globus::GRAM::JobManager module. All LRM adapter packages will
need to do this, substituting the name of the LRM type being implemented
where we see fake below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>use Globus::GRAM::Error;
use Globus::GRAM::JobState;
use Globus::GRAM::JobManager;
use Globus::Core::Paths;
use Globus::Core::Config;
use File::Path;
use strict;
use warnings;

package Globus::GRAM::JobManager::fake;

our @ISA = ('Globus::GRAM::JobManager');</pre>
</div>
</div>
<div class="paragraph">
<p>Next, we declare any system-specific values which will be read from the
configuration file. In the fake case, we will declare a module-global
directory for job information and for SEG log entries. In real LRM
Adapters, there are often variables which are loaded from the
configuration file for such things as the list of available queues,
paths to executables such as <strong>mpiexec</strong>, and any other
site-specific configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>our($job_dir, $fake_seg_dir);

BEGIN
{
    my $config = new Globus::Core::Config(
        '${sysconfdir}/globus/globus-fake.conf');

    $job_dir = $fake_seg_dir = "";

    if ($config)
    {
        $job_dir = $config-&gt;get_attribute("log_path") || "";
    }
    if ($job_dir eq '')
    {
        $job_dir = Globus::Core::Paths::eval_path('${localstatedir}/fake');
    }
}</pre>
</div>
</div>
<div class="sect4">
<h5 id="_writing_a_constructor">Writing a Constructor</h5>
<div class="paragraph">
<p>For LRM Adapter interfaces which need to setup some data before calling
their other methods, they can overload the <strong>new</strong> method which acts
as a constructor. Scheduler scripts which don&#8217;t need any per-instance
initialization will not need to provide a constructor, the default
<strong>Globus::GRAM::JobManager::new</strong> constructor will do the job.</p>
</div>
<div class="paragraph">
<p>If you do need to overloaded this method, be sure to call the parent
module&#8217;s constructor to allow it to do its initialization. In this
example, we create an object which includes a sequence number to ensure
that the job ids returned from the LRM script is unique.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class-&gt;SUPER::new(@_);
    $self-&gt;{sequence} = 0;

    return $self;
}</pre>
</div>
</div>
<div class="paragraph">
<p>The job interface methods are called with only one argument: the LRM
Adapter object itself. That object contains a
Globus::GRAM::JobDescription object
(<strong>$self-&gt;{JobDescription}</strong>) which includes the values from the RSL
associated with the request, as well as a few extra values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>job_id</strong></dt>
<dd>
<p>The string returned as the value of JOB_ID in the eturn hash from submit. This won&#8217;t be present for methods called before the job is submitted.</p>
</dd>
<dt class="hdlist1"><strong>uniq_id</strong></dt>
<dd>
<p>A string associated with this job request by the job manager program. It will be unique for all jobs on a host for all time and might be useful in creating temporary files or LRM-specific processing.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Now, let&#8217;s look at the methods which will interface to the LRM.</p>
</div>
</div>
<div class="sect4">
<h5 id="_submitting_jobs">Submitting Jobs</h5>
<div class="paragraph">
<p>All LRM adapter modules must implement the <strong>submit</strong> method. This
method is called when the job manager wishes to submit the job to the
LRM. The information in the original job request RSL string is available
to the LRM adapter interface through the JobDescription data member
of its hash.</p>
</div>
<div class="paragraph">
<p>For most LRM Adapters, this is the longest method to be implemented, as
it must decide what to do with the job description, and convert RSL
elements to something which the LRM can understand.</p>
</div>
<div class="paragraph">
<p>For our fake adapter, we will validate that the two RSL attributes we
process are integers, and if so generate a new unique LRM ID and return
it and the state <strong>Globus::GRAM::JobState::PENDING</strong>. Note the call
to <strong>respond</strong> with GT3_FAILURE_MESSAGE. This allows the GRAM5
client application to see the context-sensitive error message along with
the general failure code from GRAM5.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sub submit
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $now = time();
    my $jobid;
    my $fh;
    my $pending_time;
    my $active_time;
    my $done_time;
    my $failed_time = 0;

    if ($description-&gt;max_wall_time() != int($description-&gt;max_wall_time()))
    {
        return Globus::GRAM::Error::INVALID_MAX_WALL_TIME;
    }
    elsif ($description-&gt;max_queue_time() !=
        int($description-&gt;max_queue_time()))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Invalid max_queue_time"});

        return Globus::GRAM::Error::INVALID_ATTR;
    }
    $self-&gt;{sequence}++;
    $pending_time = $now;
    $active_time = $pending_time + int($description-&gt;max_queue_time);
    $done_time = $active_time + int($description-&gt;max_wall_time);

    $jobid = sprintf("%.63s", "$$".$self-&gt;{sequence}.".$now");

    if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
        return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
    }
    print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
    close($fh);

    return { JOB_STATE =&gt; Globus::GRAM::JobState::PENDING,
             JOB_ID =&gt; $jobid };
}</pre>
</div>
</div>
<div class="paragraph">
<p>That finishes the submit method. Most of the functionality for the
scheduler interface is now written.</p>
</div>
</div>
<div class="sect4">
<h5 id="_polling_job_state">Polling Job State</h5>
<div class="paragraph">
<p>GRAM5 requires some way to determine the state of a job. In most
systems, writing a Scheduler Event Generator module will provide the
best performance and lowest resource overhead. However, when developing
an LRM adapter, it is helpful to implement the polling interface so that
the submission and cancel mechanism can be tested independent of having
the SEG module completed. For the fake LRM Adapter, we&#8217;ll write a
simple <strong>poll</strong> method which will compare the current time with the
time when the job was originally submitted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sub poll
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $state;
    my $pid;
    my $now;
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time;
    my $seqno;

    my $jobid = $description-&gt;jobid();

    if(!defined $jobid)
    {
        $self-&gt;log("poll: job id undefined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }

        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $now = time();

    if ($pending_time == 0)
    {
        # not found
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif (int($failed_time) != 0)
    {
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif ($now &lt; int($active_time))
    {
        $state = Globus::GRAM::JobState::PENDING;
        return
    }
    elsif ($now &lt; int($done_time))
    {
        $state = Globus::GRAM::JobState::ACTIVE;
    }
    else
    {
        $state = Globus::GRAM::JobState::DONE;
    }

    return { JOB_STATE =&gt; $state };
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_cancelling_jobs">Cancelling Jobs</h5>
<div class="paragraph">
<p>All LRM Adapter modules must also implement the <strong>cancel</strong> method.
The purpose of this method is to cancel a job, whether it&#8217;s already
running or waiting in a queue.</p>
</div>
<div class="paragraph">
<p>This method will be given the job ID as part of the JobDescription
object in the manager object. If the LRM interface provides feedback
that the job was cancelled successfully, then we can return a JOB_STATE
change to the FAILED state. Otherwise we can return an empty hash
reference, and let either the Scheduler Event Generator or a subsequent
call to poll determine when the state change occurs.</p>
</div>
<div class="paragraph">
<p>For the fake LRM adapter, we will update the job file with a
cancellation time and return the Globus::GRAM::JobState::FAILED
state change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sub cancel
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $pgid;
    my $jobid = $description-&gt;jobid();
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time ;
    my $now = time();

    if(!defined $jobid)
    {
        $self-&gt;log("cancel: no jobid defined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }

        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $self-&gt;log("cancel job " . $jobid);
    if ($now &lt; int($done_time) &amp;&amp; int($failed_time) == 0)
    {
        $failed_time = $now;
        $done_time = 0;
        if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
        {
            $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
            return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
        }
        print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
        close($fh);
    }

    return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_end_of_the_script">End of the script</h5>
<div class="paragraph">
<p>It is required that all perl modules return a non-zero value when they
are parsed. To do this, make sure the last line of your module consists
of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gram5-developer-lrm-adapter-tutorial-seg">LRM SEG Module</h3>
<div class="sect3">
<h4 id="_intro">Intro</h4>
<div class="paragraph">
<p>The Scheduler Event Generator (SEG) module provides an efficient job
monitoring interface between GRAM5 and the underlying local resource
manager. In most cases, the SEG module parses a log generated by the
local resource manager which contains information about job state
changes and then uses the
<a href="http://www.globus.org/api/c-globus-{$version}/globus%5fscheduler%5fevent%5fgenerator/html/group%5f%5fseg%5f%5fapi.html">SEG
API</a> to signal job state changes as they occur.</p>
</div>
<div class="paragraph">
<p>A SEG module is implemented as a shared library which is loaded as a
globus extension. This means that the only entry point to the library is
a globus_module_descriptor, which defines activation and deactivation
functions for the library. For this tutorial, we will build up the SEG
module piecewise, but the <a href="seg_fake_module.c">entire fake SEG module
source</a> can be downloaded as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_outline">Outline</h4>
<div class="paragraph">
<p>The outline for our SEG module is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-seg-module-headers">Include Headers</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-specific-data">Module Specific Data</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-prototypes">Module Specific Prototypes</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-descriptor">Extension Module Descriptor</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-activation">Module Activation</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-deactivation">Module Deactivation</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-process">Process Events</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-utils">Utility Functions</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From this outline, we&#8217;ll explain the various sections of the source file
below.</p>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-depdendencies">LRM Module Dependencies</h4>
<div class="paragraph">
<p>The LRM module uses the globus_common API from Globus for its linked
list, mutual exclusion, timed events, and module dependency tracking. It
also uses the Scheduler Event Generator APIs, which provide functions
for defining and emitting LRM events.</p>
</div>
<div id="gram5-lrm-seg-module-headers" class="paragraph">
<div class="title">Include Headers</div>
<p>For our implementation, we&#8217;ll need to include the headers for the
Globus
modules we&#8217;ll be using. In this case we&#8217;ll be using
globus_common.h,
, globus_scheduler_event_generator.h (which
includes the API for
emitting SEG events), and  (which includes the API
for emitting SEG
events), and globus_scheduler_event_generator_app.h
(which includes
the SEG event type definitions).  (which includes the
SEG event type
definitions).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "globus_common.h"
#include "globus_scheduler_event_generator.h"
#include "globus_scheduler_event_generator_app.h"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-specific-data">Module Specific Data</h4>
<div class="paragraph">
<p>For the fake LRM, we need to keep some global state to keep track of
what we&#8217;ve parsed from our LRM&#8217;s log file, and what events are we should
be sending in the future. To do this, we define two data structures, a
fake_job_info_t which defines the set of event timestamps associated
with a job, and fake_state_t which contains the state of the fake
SEG parser.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-seg-fake-job-info">Fake Job Info</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-fake-state">Parser State</a></p>
</li>
</ul>
</div>
<div id="gram5-lrm-seg-fake-job-info" class="paragraph">
<div class="title">Fake Job Info</div>
<p>For the fake_job_info_t structure, we will want to keep track of the LRM id
(an up to 64-character long string), and the timestamps for the pending,
active, failed, and done events for the job. We use the timestamp value of
0 to indicate an event which will not happen or has already been processed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>typedef struct
{
    char  jobid[64];
    time_t pending;
    time_t active;
    time_t failed;
    time_t done;
}
fake_job_info_t;</pre>
</div>
</div>
<div class="paragraph">
<p>In addition, we will keep a null initializer for the fake_job_info_t
structure so that we can simply initialize dynamically allocated data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* A statically-initialized empty job info which is used to initialize
 * dynamically allocated fake_job_info_t structs
 */
static fake_job_info_t fake_job_info_initializer;</pre>
</div>
</div>
<div id="gram5-lrm-seg-fake-state" class="paragraph">
<div class="title">LRM Parser State</div>
<p>For the LRM parser state, we will keep track of the start time for which we
will emit events, the path to the fake job log, a file pointer open to that
log, and a list of fake_job_info_t structs for each job we have data for.
We also use a mutex/condition variable combination to block deactivation until
all callback functions have completed. The data in this struct is initialized
in the module&#8217;s activation function below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/**
 * State of the FAKE log file parser.
 */
static struct
{
    /** Timestamp of when to start generating events from */

    time_t                              start_timestamp;
    /** Log file path */
    char *                              log_path;
    /** Log file pointer */
    FILE *                              log;
    /** List of job info containing future info we might need to
      * turn into job state changes
      */
    globus_list_t *                     jobs;
    /**
     * shutdown mutex
     */
    globus_mutex_t                      mutex;
    /**
     * shutdown condition
     */
    globus_cond_t                       cond;
    /**
     * shutdown flag
     */
    globus_bool_t                       shutdown_called;
    /**
     * callback count
     */
    int                                 callback_count;
} globus_l_fake_state;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-prototypes">Module Specific Prototypes</h4>
<div class="paragraph">
<p>For our SEG, we define a small number of static functions to process the
fake job log. These include our activation and deactivation functions,
and our event callback which is called periodically to process the fake
job log. We also have a couple of utility functions to look up entries
in the job list and a predicate used to sort a list of SEG events by
timestamp and jobid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
int
globus_l_fake_module_activate(void);

static
int
globus_l_fake_module_deactivate(void);

static
void
globus_l_fake_read_callback(void *user_arg);

static
int
globus_l_fake_find_by_job_id(void * datum, void * arg);

static
int
globus_l_fake_compare_events(void * low_datum, void * high_datum, void * relation_args);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-descriptor">Extension Module Descriptor</h4>
<div class="paragraph">
<p>The SEG dynamically loads our code using the Globus Extension API. To
implement the interface it needs, we must define an extension descriptor
so that it can find the entry point to our library. This module
descriptor contains pointers to the activation and deactivation
functions we prototyped above. It can contain other pointers but they
aren&#8217;t needed for our module implementation so we leave them as NULL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GlobusExtensionDefineModule(globus_seg_fake) =
{
    "globus_seg_fake",
    globus_l_fake_module_activate,
    globus_l_fake_module_deactivate,
    NULL,
    NULL,
    NULL
};</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-activation">Module Activation</h4>
<div class="paragraph">
<p>The entry point to our LRM-specific module is the activation function.
This function is invoked by the <strong>globus-scheduler-event-generator</strong>
program when it starts and dynamically loads the LRM-specific module. It
is not passed any parameters, and is expected to return
GLOBUS_SUCCESS if it is able to activate itself. Typically the
activation function will do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
int
globus_l_fake_module_activate(void)
{</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-module-activate-declare-vars">Declare Variables</a></p>
</li>
<li>
<p><a href="#gram5-lrm-module-activate-dependencies">Activate Dependencies</a></p>
</li>
<li>
<p><a href="#gram5-lrm-module-activate-prepare-shutdown-handler">Prepare Shutdown
Handler</a></p>
</li>
<li>
<p><a href="#gram5-lrm-module-activate-read-configuration">Read Configuration</a></p>
</li>
<li>
<p><a href="#gram5-lrm-module-activate-register-event">Register Event</a></p>
</li>
<li>
<p><a href="#gram5-lrm-module-activate-cleanup-on-failure">Cleanup on Failure</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>    return result;
} /* globus_l_fake_module_activate() */</pre>
</div>
</div>
<div id="gram5-lrm-module-activate-declare-vars" class="paragraph">
<div class="title">Declare Variables</div>
<p>For our activation function, we&#8217;ll use variables to store the path to the
configuration file as well as return values from functions we call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>char *                              config_path = NULL;
char *                              log_dir;
int                                 rc;
globus_result_t                     result = GLOBUS_SUCCESS;</pre>
</div>
</div>
<div id="gram5-lrm-module-activate-dependencies" class="paragraph">
<div class="title">Activate Dependencies</div>
<p>The headers we&#8217;ve just included contain the module descriptors which we will
activate in our LRM-specific activation function, so that we are able to use
the APIs in those modules. Our module is only ever activated by the SEG module,
so we shouldn&#8217;t activate it. In the activation function for our module, we&#8217;ll
include this fragment</p>
</div>
<div class="listingblock">
<div class="content">
<pre>rc = globus_module_activate(GLOBUS_COMMON_MODULE);
if (rc != GLOBUS_SUCCESS)
{
    fprintf(stderr, "Fatal error activating GLOBUS_COMMON_MODULE\n");

    result = GLOBUS_FAILURE;
    goto activation_failure;
}</pre>
</div>
</div>
<div id="gram5-lrm-module-activate-prepare-shutdown-handler" class="paragraph">
<div class="title">Prepare Shutdown Handler</div>
<p>To handling deactivation safely, we&#8217;ll create a mutex and condition variable to
handle the case of when a shutdown is called while our event handler is
running. In that case, we&#8217;ll set the <strong>shutdown_called</strong> variable to
GLOBUS_TRUE and then wait until the callback has terminated. Here we just
set the variables to their non-shutdown values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>rc = globus_mutex_init(&amp;globus_l_fake_state.mutex, NULL);
if (rc != GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto mutex_init_failed;
}

rc = globus_cond_init(&amp;globus_l_fake_state.cond, NULL);
if (rc != GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto cond_init_failed;
}
globus_l_fake_state.shutdown_called = GLOBUS_FALSE;
globus_l_fake_state.callback_count = 0;</pre>
</div>
</div>
<div class="sect4">
<h5 id="gram5-lrm-module-activate-read-configuration">LRM SEG Module Configuration</h5>
<div id="gram5-lrm-module-activate-prepare-read-configuration" class="paragraph">
<div class="title">Read Configuration</div>
<p>There are two main pieces of configuation information we&#8217;ll need to process SEG
events: the earliest timestamp we care about (which we get from the SEG module)
and the path to our fake job log file (which we get from our configuration file
as in the perl module).</p>
</div>
<div class="paragraph">
<p>So first, to get the timestamp, we&#8217;ll use the
<strong>globus_scheduler_event_generator_get_timestamp()</strong> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>result = globus_scheduler_event_generator_get_timestamp(
        &amp;globus_l_fake_state.start_timestamp);
if (result != GLOBUS_SUCCESS)
{
    goto get_timestamp_failed;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Then, to get the configuration file data, we first construct the path to
the configuration file and then pull out the configuration attribute
log_path, falling back to the default (${localstatedir}/fake if
it is not found.  if it is not found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>result = globus_eval_path(
        "${sysconfdir}/globus/globus-fake.conf",
        &amp;config_path);
if (result != GLOBUS_SUCCESS || config_path == NULL)
{
    goto get_config_path_failed;
}
result = globus_common_get_attribute_from_config_file(
        "",
        config_path,
        "log_path",
        &amp;log_dir);

/* This default must match fake.pm's default for things to work */
if (result != GLOBUS_SUCCESS)
{
    result = globus_eval_path("${localstatedir}/fake", &amp;log_dir);
}

if (result != GLOBUS_SUCCESS)
{
    goto get_log_dir_failed;
}

globus_l_fake_state.log_path =
    globus_common_create_string("%s/fakejob.log", log_dir);
if (globus_l_fake_state.log_path == NULL)
{
    result = GLOBUS_FAILURE;

    goto get_log_path_failed;
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gram5-lrm-module-activate-register-event">Register Event</h5>
<div class="paragraph">
<p>The next main action the activation function does is to register an
event to happen later to process the events in the LRM log. For this, we
use the <strong>globus_callback_register_oneshot()</strong> function to register
an event handler to execute as soon as possible within the
<strong>globus-scheduduler-event-generator</strong> program. The callback
function in this case is the globus_l_fake_read_callback() function
defined later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>result = globus_callback_register_oneshot(
        NULL,
        NULL,
        globus_l_fake_read_callback,
        &amp;globus_l_fake_state);
if (result != GLOBUS_SUCCESS)
{
    goto register_oneshot_failed;
}
globus_l_fake_state.callback_count++;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gram5-lrm-module-activate-cleanup-on-failure">Cleanup on Failure</h5>
<div class="paragraph">
<p>Here we handle the errors that might have occurred above and free
temporarily used memory. In case of a failure, <strong>result</strong> is set to
something other than GLOBUS_SUCCESS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>register_oneshot_failed:
get_log_path_failed:
    if (result != GLOBUS_SUCCESS)
    {
        free(globus_l_fake_state.log_path);
    }
    free(log_dir);
get_log_dir_failed:
    free(config_path);
get_config_path_failed:
get_timestamp_failed:
    if (result != GLOBUS_SUCCESS)
    {
malloc_state_failed:
        globus_cond_destroy(&amp;globus_l_fake_state.cond);
cond_init_failed:
        globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
mutex_init_failed:
        globus_module_deactivate(GLOBUS_COMMON_MODULE);
    }
activation_failure:</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-deactivation">Module Deactivation</h4>
<div class="paragraph">
<p>For our deactivation function, we will wait use the shutdown handling
variables in the state structure to wait until all outstanding callback
have terminated and then free memory associated with the state.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
int
globus_l_fake_module_deactivate(void)
{</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-seg-deactivate-shutdown">Shutdown Handling</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-deactivate-free-state">Cleanup State</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>} /* globus_l_fake_module_deactivate() */</pre>
</div>
</div>
<div id="gram5-lrm-seg-deactivate-shutdown" class="paragraph">
<div class="title">Shutdown Handling</div>
<p>To handle shutdown safely, we must wait until pending callbacks have
terminated. To do this, we set the shutdown_called field in the state
structure and wait until the callback_count field is 0.  Inside the
callback function, if we see that the shutdown_called field is
GLOBUS_TRUE then it will not reregister itself and will signal when it
terminates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>globus_mutex_lock(&amp;globus_l_fake_state.mutex);
globus_l_fake_state.shutdown_called = GLOBUS_TRUE;
while (globus_l_fake_state.callback_count &gt; 0)
{
    globus_cond_wait(&amp;globus_l_fake_state.cond, &amp;globus_l_fake_state.mutex);
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);</pre>
</div>
</div>
<div id="gram5-lrm-seg-deactivate-free-state" class="paragraph">
<div class="title">Cleanup State</div>
<p>Finally, we&#8217;ll free data we allocated in the activation function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
globus_cond_destroy(&amp;globus_l_fake_state.cond);
free(globus_l_fake_state.log_path);
if (globus_l_fake_state.log)
{
    fclose(globus_l_fake_state.log);
}
while (!globus_list_empty(globus_l_fake_state.jobs))
{
    fake_job_info_t *info;

    info = globus_list_remove(
            &amp;globus_l_fake_state.jobs,
            globus_l_fake_state.jobs);

    free(info);
}

globus_module_deactivate(GLOBUS_COMMON_MODULE);

return GLOBUS_SUCCESS;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-process">Process Events</h4>
<div class="paragraph">
<p>The main activity of our LRM module is to generate SEG events so that a
job manager will be able to efficient manage its jobs. In this code, we
will parse our log file periodically, and fire off any events which are
to have occurred for the jobs in the fake job log. The structure of the
processing function is this</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
void
globus_l_fake_read_callback(void * arg)
{</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-seg-read-declare-vars">Declare Variables</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-check-for-shutdown">Check for Shutdown</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-open-log">Open Log</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-read-log">Read Log</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-create-events">Create Events</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-emit-events">Emit Events</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-reregister">Reregister Callback</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-read-error-handling">Error Handling</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>} /* globus_l_fake_read_callback() */</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-declare-vars" class="listingblock">
<div class="title">Declare Variables</div>
<div class="content">
<pre>char                                jobid[64];
globus_list_t                      *l, *events;
fake_job_info_t                     *info;
globus_reltime_t                    delay = {0};
time_t                              now;
unsigned long                       pending_time, active_time, done_time,
                                    failed_time;
globus_scheduler_event_t            *e;
time_t                              last_timestamp;
globus_result_t                     result = GLOBUS_SUCCESS;</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-check-for-shutdown" class="paragraph">
<div class="title">Check for Shutdown</div>
<p>To check for shutdown, we&#8217;ll first lock the mutex associated with the state
structure and check if the shutdown_called field is set to true. If so,
we&#8217;ll jump to our error handling code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>globus_mutex_lock(&amp;globus_l_fake_state.mutex);
if (globus_l_fake_state.shutdown_called)
{
    result = GLOBUS_FAILURE;

    goto error;
}</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-open-log" class="paragraph">
<div class="title">Open Log</div>
<p>In general, we&#8217;ll keep a file open to parse the log, but the first time around,
or before any events have been written, the log file might not exist. So we&#8217;ll
check to see if we have a NULL file pointer, and if so, try to open the
file. Once opened, we&#8217;ll use line buffering while we process the file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>if (globus_l_fake_state.log == NULL)
{
    globus_l_fake_state.log = fopen(globus_l_fake_state.log_path, "r");

    if (globus_l_fake_state.log != NULL)
    {
        /* Enable line buffering */
        setvbuf(globus_l_fake_state.log, NULL, _IOLBF, 0);

    }
}
if (globus_l_fake_state.log == NULL)
{
    result = GLOBUS_FAILURE;

    GlobusTimeReltimeSet(delay, 30, 0);
    goto reregister;
}</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-read-log" class="paragraph">
<div class="title">Read Log</div>
<p>Now we will read all of the log entries from our current position until the end
of file. If we&#8217;ve already parsed an entry for a particular job, we will zero
out its timestamps and replace with the new timestamps to handle cancel events
in the fake job log.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* previous read might have hit EOF, so clear it before trying to read */
clearerr(globus_l_fake_state.log);

/* Read any new job info from the log */
    while (fscanf(globus_l_fake_state.log,
                "%63[^;];%ld;%ld;%ld;%ld\n",
                jobid, &amp;pending_time, &amp;active_time, &amp;done_time, &amp;failed_time)
        == 5)
{
    l = globus_list_search_pred(globus_l_fake_state.jobs,
            globus_l_fake_find_by_job_id, jobid);
    if (l != NULL)
    {
        info = globus_list_first(l);
        /* If there's a second entry for the same job, it was cancelled, so
         * clear done/failed timestamps and copy them below
         */
        info-&gt;done = info-&gt;failed = 0;
    }
    else
    {
        /* First time we've seen this job, set jobid and insert*/
        info = malloc(sizeof(fake_job_info_t));
        *info = fake_job_info_initializer;
        strcpy(info-&gt;jobid, jobid);

        globus_list_insert(&amp;globus_l_fake_state.jobs, info);
    }
    /* set timestamps */
    info-&gt;pending = pending_time;
    info-&gt;active = active_time;
    info-&gt;done = done_time;
    info-&gt;failed = failed_time;
}</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-create-events" class="paragraph">
<div class="title">Create Events</div>
<p>Now, we&#8217;ll walk our list of jobs and create SEG events for each state
transition which has occurred since our last timestamp and the current time.
These events will be out of order in our events list, because they are created
in order of job IDs in the jobs list, and not in timestamp list. We&#8217;ll deal
with this later. Note that we set the timestamp values in the job info to 0
after we create an event. This keeps us from generating an event multiple
times.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* Create set of events that we'll emit this time through: jobs which will
 * changed state since our last event update
 */
now = time(NULL);

events = NULL;
for (l = globus_l_fake_state.jobs; l != NULL; l = globus_list_rest(l))
{
    info = globus_list_first(l);

    if (info-&gt;pending &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;pending &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_PENDING;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;pending;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;pending = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;active &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;active &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_ACTIVE;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;active;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;active = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;done != 0 &amp;&amp; info-&gt;done &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;done &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_DONE;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;done;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;done = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;failed != 0 &amp;&amp;
        info-&gt;failed &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;failed &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_FAILED;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;failed;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = GLOBUS_GRAM_PROTOCOL_ERROR_USER_CANCELLED;
        e-&gt;raw_event = NULL;

        info-&gt;failed = 0;
        globus_list_insert(&amp;events, e);
    }
}</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-emit-events" class="paragraph">
<div class="title">Emit Events</div>
<p>Now we have a set of events, we will sort them by timestamp and then use the
SEG API to emit them. After we&#8217;ve emitted an event, we have to free it. If the
event is a terminal one (DONE or FAILED) we&#8217;ll remove the job from the list of
jobs in the state structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/* Sort the events so that they're in timestamp order */
events = globus_list_sort_destructive(
        events, globus_l_fake_compare_events, NULL);

/* Emit events in proper order */
while (! globus_list_empty(events))
{
    e = globus_list_remove(&amp;events, events);
    last_timestamp = e-&gt;timestamp;

    switch (e-&gt;event_type)
    {
        case GLOBUS_SCHEDULER_EVENT_PENDING:
            globus_scheduler_event_pending(e-&gt;timestamp, e-&gt;job_id);
            break;
        case GLOBUS_SCHEDULER_EVENT_ACTIVE:
            globus_scheduler_event_active(e-&gt;timestamp, e-&gt;job_id);
            break;
        case GLOBUS_SCHEDULER_EVENT_FAILED:
            globus_scheduler_event_failed(e-&gt;timestamp, e-&gt;job_id,
                    e-&gt;failure_code);
            break;
        case GLOBUS_SCHEDULER_EVENT_DONE:
            globus_scheduler_event_done(e-&gt;timestamp, e-&gt;job_id, e-&gt;exit_code);
            break;
    }
    /* If this is a terminal event, we can remove the job from the list */
    if (e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_FAILED ||
        e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_DONE)
    {
        l = globus_list_search_pred(globus_l_fake_state.jobs,
                globus_l_fake_find_by_job_id, e-&gt;job_id);
        info = globus_list_remove(&amp;globus_l_fake_state.jobs, l);
        free(info);
    }

    free(e);
}
globus_l_fake_state.start_timestamp = last_timestamp;</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-reregister" class="paragraph">
<div class="title">Reregister Callback</div>
<p>We&#8217;ll register a new callback instance now (provided we haven&#8217;t had
an error occur) so that we can continue to process jobs later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    GlobusTimeReltimeSet(delay, 1, 0);
reregister:
    result = globus_callback_register_oneshot(
            NULL,
            &amp;delay,

    globus_l_fake_read_callback, &amp;globus_l_fake_state);
    if (result != GLOBUS_SUCCESS)
    {
        goto error;
    }
    globus_mutex_unlock(&amp;globus_l_fake_state.mutex);
return;</pre>
</div>
</div>
<div id="gram5-lrm-seg-read-error-handling" class="paragraph">
<div class="title">Error Handling</div>
<p>If an error occurred registering the event or the shutdown handler is invoked,
we&#8217;ll exit this function without registering a new event.  In the case the
shutdown handling is in place, we&#8217;ll signal that as well</p>
</div>
<div class="listingblock">
<div class="content">
<pre>error:
    if (globus_l_fake_state.shutdown_called)
    {
        globus_l_fake_state.callback_count--;

        if (globus_l_fake_state.callback_count == 0)
        {
            globus_cond_signal(&amp;globus_l_fake_state.cond);
        }
    }
    else
    {
        fprintf(stderr,
            "FATAL: Unable to register callback. FAKE SEG exiting\n");

        exit(EXIT_FAILURE);
    }
    globus_mutex_unlock(&amp;globus_l_fake_state.mutex);

    return;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gram5-lrm-seg-module-utils">Utility Functions</h4>
<div class="paragraph">
<p>We have two utility functions to implement for this module to manage our
lists of pending events and jobs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gram5-lrm-seg-module-find-job">Find By Job ID</a></p>
</li>
<li>
<p><a href="#gram5-lrm-seg-module-compare-events">Sort Events</a></p>
</li>
</ul>
</div>
<div id="gram5-lrm-seg-module-find-job" class="paragraph">
<div class="title">Find By Job ID</div>
<p>The <strong>globus_l_fake_find_by_job_id()</strong> function is used to search the
jobs field of the state structure for a fake_job_info_t containing info
about a particular job. This predicate returns a non-zero value if the 'datum'
passed to the function has the same job ID as the 'arg' parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
int
globus_l_fake_find_by_job_id(void * datum, void * arg)
{
    fake_job_info_t * info = datum;

    return (strcmp(info-&gt;jobid, arg) == 0);
} /* globus_l_fake_find_by_job_id() */</pre>
</div>
</div>
<div id="gram5-lrm-seg-module-compare-events" class="paragraph">
<div class="title">Sort Events</div>
<p>The <strong>globus_l_fake_compare_events()</strong> function is used as a predicate to
compare the timestamps and job ids of a pair of events.  If the 'log_datum'
points to an event which happens earlier in the job lifecycle than the
'high_datum', this function returns GLOBUS_TRUE; otherwise it returns
GLOBUS_FALSE.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static
int
globus_l_fake_compare_events(void * low_datum, void * high_datum,
        void * relation_args)
{
    globus_scheduler_event_t *low_event = low_datum, *high_event = high_datum;

    if (low_event-&gt;timestamp &lt; high_event-&gt;timestamp)
    {
        return GLOBUS_TRUE;
    }
    else if (low_event-&gt;timestamp == high_event-&gt;timestamp)
    {
        if (low_event-&gt;event_type == GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return GLOBUS_TRUE;
        }
        else if (low_event-&gt;event_type == GLOBUS_SCHEDULER_EVENT_ACTIVE &amp;&amp;
                high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return GLOBUS_TRUE;
        }
        else if (high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_PENDING &amp;&amp;
            high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_ACTIVE)
        {
            return GLOBUS_TRUE;
        }
    }
    return GLOBUS_FALSE;
} /*
globus_l_fake_compare_events() */</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gram5-lrma-tutorial-perl-changes">Changes from Previous Versions</h3>
<div class="sect3">
<h4 id="_changes_in_gt_5_2">Changes in GT 5.2</h4>
<div class="paragraph">
<p>GRAM5 is now designed to work as a native debian or RPM package, with
default configuration being done at configuration time, so the setup
script description has been removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_gt_5_0">Changes in GT 5.0</h4>
<div class="paragraph">
<p>GRAM5 is based again on the C code base used for GRAM2 (also known as
Pre-WS GRAM). The SEG module interface from GRAM4 is retained and
optionally used by GRAM5. The GRAM job manager will avoid reloading the
GRAM LRM Adapter script for each operation, so all variables not
intended to be global state in the Perl LRM Adapter module must be
lexically scoped, or state will leak between jobs and cause potentially
cause problems.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_gt_4_0">Changes in GT 4.0</h4>
<div class="sect4">
<h5 id="_module_methods">Module Methods</h5>
<div class="paragraph">
<p>The GT-4.0 ws-GRAM service only calls a subset of the Perl methods which
were used by the pre-ws GRAM services. Most importantly for script
implementors, the polling method is no longer used. Instead, the
scheduler-event-generator monitors jobs to signal the service when job
change changes occur. Staging is now done via the Reliable File Transfer
service, so the file_stage_in and file_stage_out methods are no longer
called. Schedulers typically did not implement the staging methods, so
this shouldn&#8217;t affect most scheduler modules.</p>
</div>
<div class="paragraph">
<p>That being said, scheduler implementers which would like to have their
scheduler both with pre-ws GRAM and WS-GRAM should definitely implement
the poll() method described in the pre-WS version of this tutorial.</p>
</div>
</div>
<div class="sect4">
<h5 id="_gass_cache">GASS Cache</h5>
<div class="paragraph">
<p>The GT-4.0 ws-GRAM service does not use the GASS cache for storing
temporary files or for staging files.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_gt_3_2">Changes in GT 3.2</h4>
<div class="paragraph">
<p>In GT 3.2, additional error message context info was added. Scripts can
optionally add one of these fields to the return hash from an operation
to provide extra error information to the client:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>GT3_FAILURE_MESSAGE</strong></dt>
<dd>
<p>Error message from underlying script processing indicating what caused a job request to fail</p>
</dd>
<dt class="hdlist1"><strong>GT3_FAILURE_TYPE</strong></dt>
<dd>
<p>One of filestagein, filestageout, filestageinshared, executable, or stdin indicating what job request element caused a staging fault.</p>
</dd>
<dt class="hdlist1"><strong>GT3_FAILURE_SOURCE</strong></dt>
<dd>
<p>Source URL or file for a failed staging operation</p>
</dd>
<dt class="hdlist1"><strong>GT3_FAILURE_DESTINATION</strong></dt>
<dd>
<p>Destination URL or file for a failed staging operation</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-02-09 14:17:03 CST
</div>
</div>
</body>
</html>